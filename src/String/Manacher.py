
# O(n) 时间内求出字符串的最长回文串

def manacher(s):
    #改造字符串
    s = '$#' + '#'.join(s) + '#'
    l, r = 1, 1
    d = [0] * (len(s))
    d[1] = 1
    for i in range(2, len(s)):
        #在盒内，两者取最小
        if i <= r: d[i] = min(d[r - i + 1], r - i + 1)
        #超出部分暴力枚举
        while (i + d[i] < len(s) and s[i - d[i]] == s[i + d[i]]): d[i] += 1
        # 更新盒子l, r
        if i + d[i] - 1 > r: l, r = i - d[i] + 1, i + d[i] - 1
    return d


# d[i] 表示以i为中心的最长回文串长度的一半，即：回文半径。
# 加速盒子[l, r]
# 算法过程中我们 维护右端点最靠右的最长回文串，利用盒子，借助之前的状态
# 来加速计算新状态，盒内d[i]可以利用对称点转移，盒外暴力。


# 1) 改造字符串，将字符串 之间 和 两端  插入 '#'   s[0] = '$' 边界(哨兵)
# 2) 计算完前i-1的d值，盒子长度为[l,r]
# 1. 如果 i<=r (在盒内), i 的对称点为 r-i+l
#    i.若d[r-i+l]<r-i+1,半径为超出r(可以安全转移)，则d[i]=d[r-i+l]
#   ii.若d[r-i+l]>=r-i+1, 则d[i]=d[r-i+l]，从r+1往后暴力枚举
# 2. 如果i>r(在盒外),则从i开始枚举
# 3. 求出d[i]后，如果i+d[i]-1>r,则更新盒子，l=i+d[i]-1, r=i+d[i]-1
